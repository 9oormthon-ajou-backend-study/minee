## 3장 영속성 관리

### 3.1 엔티티 매니저 팩토리와 엔티티 매니저

- 엔티티 매니저 팩토리는 엔티티 매니저를 만드는 공장. 만드는 비용이 상당히 크다.
    - 한 개만 만들어서 애플리케이션 전체에서 공유하도록 설계되어 있다.
- 반면 공장에서 엔티티 매니저를 만드는  것은 비용이 거의 안 든다.
- 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 됨 → 다른 스레드 간의 공유 OK
    - 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생 → 절대 공유하면 안 된다.
- JPA 구현체들은 엔티티 매니저 팩토리를 생성할 때 커넥션 풀도 만든다.

### 3.2 영속성 컨텍스트 persistence context

- 엔티티를 영구 저장하는 환경
- em.persist(member);는 엔티티 매니저를 사용해서 member 엔티티를 영속성 컨텍스트에 저장하는 것
- 영속성 컨텍스트는 엔티티 매니저가 하나 만들어질 때 하나씩 같이 만들어진다. 여러 엔티티 매니저가 하나의 영속성 컨텍스트를 바라볼 수도 있다.

### 3.3 엔티티의 생명 주기

엔티티의 4가지 상태 

- 비영속 (new/transient)
    - 영속성 컨텍스트와 전혀 관계가 없는 상태
    - em.persist()로 영속 상태로 만들 수 있다.
    - 영속된 적 없으므로 id가 존재하지 않을 수도 있다.
- 영속 (managed)
    - 영속성 컨텍스트에 저장된 상태
- 준영속 (detached)
    - 영속성 컨텍스트에 저장되었다가 분리된 상태
    - id가 반드시 존재한다. (영속 상태였으므로)
    - em.detach()로 영속 상태의 엔티티를 준영속 상태로 만들 수 있다.
    - em.clos()로 엔티티 매니저를 닫거나 em.clear()로 엔티티 매니저를 초기화해도 관리하던 엔티티들이 준영속 상태가 된다.
- 삭제 (removed)
    - 삭제된 상태
    - em.remove()로 엔티티를 영속성 컨텍스트에서 삭제한 상태
    

### 3.4 영속성 컨텍스트의 특징
- 엔티티를 식별자 값 (@Id로 매핑한 값)으로 구분한다. 영속 상태의 엔티티는 반드시 식별자 값이 있어야 한다.

#### 3.4.1 엔티티 조회
- em.find(엔티티 클래스의 타입, id) 로 엔티티를 조회할 수 있다.
    - em.find()는 영속성 컨텍스트 내의 1차 캐시에서 엔티티를 찾는다.
    - 만약 1차 캐시에 없으면 데이터베이스에서 조회 → 엔티티를 생성 → 1차 캐시에 저장
        - 영속 상태의 엔티티를 반환한다.

엔티티 컨텍스트는 엔티티를 호출할 때 캐시에 엔티티가 남아 있으면 같은 엔티티를 반환하므로

- 성능 상의 이점을 갖는다. (데이터베이스에 여러 번 접근할 필요가 없음)
- 호출된 엔티티의 동일성 (==)을 보장한다.

#### 3.4.2 엔티티 등록
- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 쿼리하지 않고 쿼리들을 쿼리 저장소에 모아둔다.
- 트랜잭션이 커밋되면 영속성 컨텍스트가 flush 되면서 쿼리를 한 번에 보낸다.
- 어차피 트랜잭션이 커밋되지 않으면 쿼리가 전달되어도 소용이 없다.
- 그래서 데이터베이스에 덜 접근하기 위해 쓰기 지연을 사용한다.

#### 3.4.3 엔티티 수정
- JPA로 엔티티를 수정할 때: 엔티티 조회 → 데이터 변경
    - entity.setField() 수정자를 쓰면 된다.
    - 이렇게 해서 변경된 것은 JPA나 엔티티 매니저에게 알려주지 않아도 된다.
    - 자동으로 반영하기 때문에: 변경 감지 (dirty checking)
- 변경 감지 (dirty checking)
    - JPA는 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 저장해 둔다. (스냅샷)
    - 플러시하는 시점에 스냅샷과 엔티티를 비교해 달라진 엔티티를 찾는다.
    - 변경 감지는 영속 상태의 엔티티에만 적용된다.
    - 변경 감지로 인해 데이터베이스가 업데이트 될 때:
        - JPA는 기본적으로 엔티티의 모든 필드를 업데이트 한다.
        - 장점:
            - 수정 쿼리가 항상 같다. (데이터 값은 다르지만)
            - 동일한 쿼리를 보내면 데이터배이스는 이미 파싱된 쿼리를 재사용할 수 있다.
        - 단점:
            - 필드가 많거나 저장되는 내용이 너무 크면 비효율적임.
            
            → 이럴 땐 동적으로 UPDATE SQL을 생성하는 전략을 선택하면 된다. hibernate 확장 기능을 사용해서 할 수 있다.
            

#### 3.4.4 엔티티 삭제 

- em.remove()로 엔티티를 넘기면 삭제할 수 있다.
    - 바로 삭제하는 것이 아니라 삭제 쿼리를 쿼리 저장소에 등록해 둔다.
    - 하지만 em.remove()를 호출하는 순간 영속성 컨텍스트에서는 제거된다.

### 3.5 플러시

- 플러시 (flush())는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.
- em.flush(), 트랜잭션 커밋, JPQL 쿼리 실행 시 영속성 컨텍스트를 플러시할 수 있다.
    - JPQL을 실행하기 전에 flush하지 않으면 그동안의 변경 사항을 JPQL 결과에 반영할 수 없다. 그래서 JPQL 쿼리를 실행하면 SQL 쿼리로 변환해 날리기 직전에 flush를 먼저 실행한다.
    - em.find() 는 flush를 실행하지 않는다.

### 3.6 준영속

- 준영속 상태로 만드는 데에는 세 가지 방법이 있다: em.detach(entity), em.clear(), em.close()
    - em.detach()를 하면 해당 엔티티에 관련된 SQL도 SQL 저장소에서 모두 삭제되어 flush할 때 실행되지 않는다.
