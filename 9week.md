# 9장. 값 타입 
- 값 타입은 단순히 값으로만 사용되는 자바 기본 타입이나 객체를 말한다.
  - 값이 다르면 다른 객체가 된다. (1 != 2, ..., )
  - 엔티티 타입은 일부 값이 바뀌어도 식별자로 구분할 수 있다.
- 값 타입들은 엔티티의 생명 주기에 의존한다.

## 9.1 기본값 타입 
- int, double 같은 자바 기본 타입 
- String ... 
- 엔티티에 속한 값 타입은 다른 엔티티랑 공유하면 안된다.

## 9.2 임베디드 타입 (복합 값 타입)
- 새로운 값 타입을 직접 정의해서 쓸 수 있다. 
- 변수나 필드로 선언할 때 @Embedded 어노테이션을 쓴다.
- 정의할 때는 @Embeddable을 쓴다. 
- 구조체 같은 느낌

- 임베디드 타입을 테이블에 매핑할 때는 임베디드 타입의 필드를 다 꺼내서 각각을 매핑한다.
- 임베디드 타입이 null이면 매핑된 컬럼 값은 모두 null이 된다.
- 같은 임베디드 타입을 여러 개 쓰면 매핑하는 컬럼명이 중복되는 문제가 생길 수 있다.
    - @AttributeOverrides를 써서 매핑정보를 재정의하면 댐 

## 9.3 값 타입과 불변 객체
- 값 타입의 인스턴스를 여러 엔티티에서 공유하면 안된다.
- 값만 복사해서 쓰자
- 객체.clone() 하면 값이 복사된다. 
- 머 암튼 이렇게 할 수 있지만 자바는 객체를 넘겨줄 때 항상 인스턴스를 넘긴다.
  - 그래서 원치 않는 변경 (넘겨받은 애가 다바꿔버림)을 안전하게 막기가 어렵다.
  - 그래서 불변 객체라는 것이 등장함 (부작용을 없애버리자)
  - 객체를 불변하게 (immutable하게) 만들면 수정을 못하니까 부작용이 없다.
  - 불변하게 만들려면 생성자만 놓고 수정자를 안 만들면 된다. 바꾸고 싶으면 새로 만들어서 갈아 끼워야 한다.

## 9.4 값 타입의 비교 
- 값 타입은 인스턴스가 아니라 값 (객체)가 같은지 비교해야 하기 때문에 '==' (동일성 비교)가 아니라 equals (동등성 비교)로 비교해야 한다. 값 타입의 equals를 구현할 때는 모든 필드의 값을 비교하도록 구현한다.


## 9.5 값 타입 컬렉션 
- 필드에 컬렉션을 넣으려면 필드를 정의할 때 @ElementConnection, @CollectionTable을 쓰면 된다.
- 한 cell에는 여러 값을 넣을 수 없으니까 컬렉션을 만들려면 컬렉션만 정의하는 테이블을 따로 둔다. 