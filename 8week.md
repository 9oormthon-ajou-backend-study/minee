# 8장. 프록시와 연관관계 관리

## 8.1 프록시 
어떤 엔티티를 조회할 때 연관된 엔티티들을 모두 불러올 필요가 없을 수도 있다. 
- (EX) 회원 엔티티의 이름을 조회할 때, 팀 엔티티가 연관되어 있지만 필요 없음 
근데 이걸 메번 다 불러오는 건 효율적이지 않다.
→ 이걸 해결하려고 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 만듦: 이것을 지연 로딩이라고 한다. 
- 지연 로딩을 사용하려면 실제 객체 대신 들어가 있을 가짜 객체가 필요 → 얘가 프록시 

### 8.1.1 프록시 기초
- 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루고 싶으면 ''EntityManager.getReference()''를 사용한다. 
  - 이 메소드는 데이터베이스를 조회하지 않고 DB 접근을 위임한 프록시 객체를 반환한다.
- 프록시의 특징
  - 원래 클래스를 상속받아 만듦 → 실제 클래스와 겉으로 보기에 같다.
  - 사용하는 입장에서는 진짜인지 프록시인지 신경 안 써도 된다.
  - 프록시 객체는 실제 객체의 참조(target)를 보관한다. 
  - 프록시 객체의 메소드를 호출하면 프록시 객체가 실제 객체의 메소드를 호출한다.
  - 프록시는 처음 사용할 때 딱 한 번만 초기화한다.
  - 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 써도 프록시 말고 진짜 엔티티를 준다.
  - 프록시 초기화는 영속성 컨텍스트의 도움을 받아야 한다. → 준영속 상태면 예외가 터진다. 
- 프록시 객체의 초기화 
  - 프록시 객체의 메소드를 호출해서 뭔가 요청했을 때 실제 엔티티가 생성되어 있지 않으면 (있으면 걍 꺼내옴) 영속성 컨텍스트에 실제 엔티티 생성을 요청함. 요것이 초기화 
  - 영속성 컨텍스트가 엔티티 객체를 생성해서 주면 target에 참조를 저장한다.

### 8.1.2 프록시와 식별자 
- 엔티티를 프록시로 조회할 때 식별자 (PK)를 파라미터로 전달. 프록시 객체는 이 PK 값을 보관한다.
  - 그래서 프록시.식별자조회() 하면 데이터베이스 조회를 하지 않는다. (어차피 프록시도 갖고 있음)
  - 근데 사실? 이것은 엔티티 접근 방식을 프로퍼티 (@AccessType.PROPERTY)로 설정했을 때만 그럼
  - 필드 (@Access(AccessType.FIELD))로 설정하면 JPA는 프록시 객체를 초기화한다.

### 8.1.3 프록시 확인 
- ''emf.gerPersistenceUnitUtil().isLoaded(entity);'' 하면 프록시 인스턴스가 초기화 되었는지 확인할 수 있다 
  - 초기화되지 않은 인스턴스는 false, 초기화되었거나 프록시가 아니면 true를 반환한다.
  - 프록시인지 아닌지 확인하려면 클래스 이름을 직접 출력해 보면 된다.

#### cf: 프록시 강제 초기화
- JPA에는 프록시를 강제로 초기화할 수 있는 메소드가 따로 없다. (하이버네이트는 initialize()로 할 수 있음)
- member.getName()처럼 프록시의 메소드를 직접 호출해서 초기화할 수 있다.

## 8.2 즉시 로딩과 지연 로딩 
### 8.2.1 즉시 로딩: 엔티티를 조회할 때 연관된 엔티티도 함께 즉시 조회한다.
- 설정 방법: @ManyToOne(fetch= FetchType.**EAGER**)
- 대부분의 JPA 구현체는 즉시 로딩할 때 조인 쿼리를 쓴다. 
  - Member 엔티티를 조회하는 순간 MEMBER table과 TEAM table을 JOIN해서 Team 엔티티를 꺼내온다.
  - 쿼리 한 번으로 해결할 수 있도록 최적화한 것임
  - cf) 조인할 때는 OUTER JOIN을 쓴다. Team이 nullable할 수도 있기 때문. INNER JOIN이 성능과 최적화 면에서 더 유리함. @JoinColumn에 nullable = false (이 column이 not nullable하다고 알려줌) 을 설정하면 JPA에 INNER JOIN을 쓴다. 

### 8.2.2 지연 로딩: 연관된 엔티티를 실제 사용할 때 조회한다.
- 설정 방법: @ManyToOne(fetch= FetchType.**LAZY**)

## 8.3 지연 로딩 활용
### 8.3.1 컬렉션 래퍼 
- 하이버네이트는 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면 원본 컬렉션을 하이버네이트 내장 컬렉션으로 변경함. → 요게 컬렉션 래퍼 
- 컬렉션 래퍼는 컬렉션의 프록시처럼 동작한다.
- 지연 로딩 - Member에 Orders (List<Order>)가 있을 때:
  - member.getOrders() 한다고 해서 컬렉션이 초기화되지 않는다.
  - member.getOrders().get(0)과 같이, 실제 order를 꺼낼 때 초기화한다.

### 8.3.2 JPA 기본 Fetch 전략 
**기본값** 
- @ManyToOne, @OneToOne: 즉시 로딩
- @OneToMany, @ManyToMany: 지연 로딩 
- 아묻따 지연 로딩하기를 권장 → 개발이 어느 정도 되고 나서 꼭 필요할 때만 즉시 로딩을 쓰도록 최적화하면 된다. 

## 8.4 영속성 전이: CASCADE 
- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들가
- 영속성 전이 (transitive persistence) → JPA는 CASCADE 옵션으로 요걸 할 수 있게 한다.
- 매핑할 때 cascade = CascadeType.PERSIST 하면 된다. (''@OneToMany (cascade = CascadeType. ...''))

### 8.4.1 영속성 전이: 저장 
- cascade  = CascadeType.PERSIST
  - 영속화할 때 연관된 엔티티도 함께 영속화된다.

### 8.4.2 영속성 전이: 삭제 
- cascade = cascadeType.REMOVE 
  - 삭제할 때 연관된 엔티티들도 함께 삭제된다.
  - 요거 안 걸면 참조 무결성이 침해될 수 있다. 

### 8.4.3 그 외 
- ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH
- 다양한 게 있고 여러 개를 동시에 같이 쓸 수도 있다. 

## 8.5 고아 객체 
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제 → 고아 객체 제거라 한다.
- 매핑할 때 orphanRemoval = true 로 설정하면 된다.
- 참조가 제거된 객체를 자동으로 삭제하는 기능 
  - 여러 곳에서 참조하는 객체에 사용하면 안된다.
  - 그래서 @OneToMany, @OneToOne에만 사용할 수 있다.

## 8.6 영속성 전이 + 고아 객체, 생명주기
- CascadeType.ALL과 orphanRemoval = true를 동시에 사용하면 부모 엔티티로 자식의 생명주기를 관리할 수 있게 된다.


