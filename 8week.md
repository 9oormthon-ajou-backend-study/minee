# 8장. 프록시와 연관관계 관리

## 8.1 프록시 
어떤 엔티티를 조회할 때 연관된 엔티티들을 모두 불러올 필요가 없을 수도 있다. 
- (EX) 회원 엔티티의 이름을 조회할 때, 팀 엔티티가 연관되어 있지만 필요 없음 
근데 이걸 메번 다 불러오는 건 효율적이지 않다.
→ 이걸 해결하려고 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 만듦: 이것을 지연 로딩이라고 한다. 
- 지연 로딩을 사용하려면 실제 객체 대신 들어가 있을 가짜 객체가 필요 → 얘가 프록시 

### 8.1.1 프록시 기초
- 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루고 싶으면 ''EntityManager.getReference()''를 사용한다. 
  - 이 메소드는 데이터베이스를 조회하지 않고 DB 접근을 위임한 프록시 객체를 반환한다.
- 프록시의 특징
  - 원래 클래스를 상속받아 만듦 → 실제 클래스와 겉으로 보기에 같다.
  - 사용하는 입장에서는 진짜인지 프록시인지 신경 안 써도 된다.
  - 프록시 객체는 실제 객체의 참조(target)를 보관한다. 
  - 프록시 객체의 메소드를 호출하면 프록시 객체가 실제 객체의 메소드를 호출한다.
  - 프록시는 처음 사용할 때 딱 한 번만 초기화한다.
  - 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 써도 프록시 말고 진짜 엔티티를 준다.
  - 프록시 초기화는 영속성 컨텍스트의 도움을 받아야 한다. → 준영속 상태면 예외가 터진다. 
- 프록시 객체의 초기화 
  - 프록시 객체의 메소드를 호출해서 뭔가 요청했을 때 실제 엔티티가 생성되어 있지 않으면 (있으면 걍 꺼내옴) 영속성 컨텍스트에 실제 엔티티 생성을 요청함. 요것이 초기화 
  - 영속성 컨텍스트가 엔티티 객체를 생성해서 주면 target에 참조를 저장한다.

### 8.1.2 프록시와 식별자 
- 엔티티를 프록시로 조회할 때 식별자 (PK)를 파라미터로 전달. 프록시 객체는 이 PK 값을 보관한다.
  - 그래서 프록시.식별자조회() 하면 데이터베이스 조회를 하지 않는다. (어차피 프록시도 갖고 있음)
  - 근데 사실? 이것은 엔티티 접근 방식을 프로퍼티 (@AccessType.PROPERTY)로 설정했을 때만 그럼
  - 필드 (@Access(AccessType.FIELD))로 설정하면 JPA는 프록시 객체를 초기화한다.

### 8.1.3 프록시 확인 
- ''emf.gerPersistenceUnitUtil().isLoaded(entity);'' 하면 프록시 인스턴스가 초기화 되었는지 확인할 수 있다 
  - 초기화되지 않은 인스턴스는 false, 초기화되었거나 프록시가 아니면 true를 반환한다.
  - 프록시인지 아닌지 확인하려면 클래스 이름을 직접 출력해 보면 된다.

#### cf: 프록시 강제 초기화
- JPA에는 프록시를 강제로 초기화할 수 있는 메소드가 따로 없다. (하이버네이트는 initialize()로 할 수 있음)
- member.getName()처럼 프록시의 메소드를 직접 호출해서 초기화할 수 있다.